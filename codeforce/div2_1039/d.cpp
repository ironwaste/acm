// 看什么看,以为我厉害吗？
// 我只是戾气很重,不厉害只需要114514分钟就能变厉害了
// 而你我的朋友只需要2.5年就可以了
#include<bits/stdc++.h>
#include<climits>


#define all(x) x.begin(),x.end()
#define pb(x) push_back(x)
#define i64 long long
#define fi first
#define se second

#define endl '\n'
#define mod3 998244353
#define mod7 1000000007
#define de(x) cerr << #x <<" "<<x <<" ";
#define deb(x) cerr << #x <<" "<<x <<endl;
using namespace std;

using pii = pair<int,int>;
using pll = pair<i64, i64>;

// 2025.07.27——23:36:24
// 2025.07.28——00:37:05 超时2分钟最后叹气
/*
 * 题目意思 ： 给出一个排列， 其中该排列满足以下条件：
 * 1、 对于所有位， 前两个数 的最大值 大于第三个数 max(p[i],p[i+1]) > p[i+2]
 *  <==> 意味着 如果确定了 值 n 那么 n-1 一定在 n 的后面两个中
 * 
 * 也就是 意味着 其可能不是完全递减的存在，
 *  [3,2,1] [3,1,2] [2,3,1] [1,3,2] 
 *  [1,2,3] [2,1,3] 不可以
 * [3,2,1] -> 10 递增连续子序列的长度和
 * [3,1,2] -> 8 3(1个的存在) + (2 + 1)(长度为2 的存在[3,1]) + (2) 长度为三的存在
 * [2,3,1] -> 
 * 可以想到 其中最长的降序子序列，在于长度大于它之上的 所有情况，都贡献了它的长度
 * dp可以在 nlogn的时间复杂度内算出 以0为起点到每个r上的 最长降序子序列
 *
 * 3 1
 * 3 2 -> 1 + 2
 * 3 2 1 -> 1 + 2 + 3 ->10
 *
 * 3 1 2
 * 3 -> 1
 * 3 1 -> 2 + 1
 * 3 1 2 -> 2 + 1 + 1
 *
 * 2 3 1
 * 2 -> 1
 * 2 3 -> 1 + 1
 * 2 3 1 -> 2 + 2 + 1
 *
 * 4 -> 1
 * 4 3 -> 2 + 1
 * 4 3 1 -> 3 + 2 + 1
 * 4 3 2 -> 3 + 2 + 1 + 1-> 16? 
 * 
 * 6 -> 1
 * 6 1 -> 2 + 1
 * 6 1 5- > 2 + 1 + 1
 * 6 1 5 2 -> 3 + 2 + 2 + 1
 * 6 1 5 2 4 -> 3 + 2 + 2 + 1 + 1;
 * 6 1 5 2 4 3 -> 4 + 3 + 3 + 2 + 2 + 1
 * 也就是 前面大于 当前值的数字的值会 +1
 * 而小于的不会增加
 * 所以可以维护一个树状数组， 用于查询 大于 当前值v的数字的个数以及长度
 *
 * 相当于在优化 ，遍历左端点的 情况
 * 可以进行以下操作，当我们在选择一个数字的时候，如果这个数字小于前面所有的数字，
 * 则加入到数组中 ，有问题 ？ 问题在于当我们 有一个并不是降序的数字加入之后
 * 其内部结构或者说加和 的数值就会发生改变
 *
 * 如果小于的话 则 += 长度 * 1
 * 如果不小于的话  直接加1
 *
 * 样例 6 1 4 2 5 3
 * 6 -> 1
 * 6 1 -> 2 1
 * 6 1 4 -> 2 1 1
 * 6 1 4 2 -> 3 2 2 1
 * 6 1 4 2 5 -> 3 2 2 1 1
 * 6 1 4 2 5 3 -> 3 2 2 2 2 1 //这种情况不会出现，所以就是只会有上面的情况
 *
 * 6 3 5 2 4 1
 * 6 - 》 1
 * 6 3 -> 2 + 1
 * 6 3 5 -> 2 + 1 + 1
 * 6 3 5 2 -> 3 + 2 + 2 + 1
 *
 * 4 -> 1
 * 4 3 -> 2 + 1
 * 4 3 1 -> 3 + 2 + 1
 * 4 3 1 2 -> 3 + 2 + 1 + 1
 *
 * 前面有几个数字当前这个就加多少
 * 其实是找 第一个比它小的值，之前比当前这个值大的数字有多少
*/
// const int N = 5e5 + 10;
// i64 lowbit(i64 x) {
//     return x & (-x);
// }
const int N = 5e5 + 10;
i64 tree[N];
i64 lowbit(i64 x) {
    return x & (-x);
}

i64 add(i64 x,i64 v) {
    for (;x < N;x += lowbit(x)) {
        tree[x]+=v;
    }
}

i64 query(i64 x) {
    i64 res = 0LL;
    for (;x;x -= lowbit(x)) {
        res += tree[x];
    }
    return res;
}

void solve() {
    i64 n;
    cin >> n;
    vector<i64>p(n);
    for (auto& x : p) { cin >> x; }
    i64 ans = 0,pre = 0;
    for (int i = 0;i < n;i++) {
        i64 cntv = p[i];
        if (i != 0 && cntv < p[i - 1]) {
            pre = pre + i;
        }
        pre = pre + 1LL;
        // de(pre)
        ans += pre;
        // deb(ans)
    }
    // deb(ans);
    // for (int i = 1;i <= n;i ++ ) {
    //     add(i, -1);
    // }
    cout << ans << endl;

}

int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int T;
    cin >> T;
    while(T--){
        solve();
    }
    return 0;
}