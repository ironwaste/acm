// 看什么看,以为我厉害吗？
// 我只是戾气很重,不厉害只需要114514分钟就能变厉害了
// 而你我的朋友只需要2.5年就可以了
#include<bits/stdc++.h>
#include<climits>


#define all(x) x.begin(),x.end()
#define pb(x) push_back(x)
#define i64 long long
#define fi first
#define se second

#define endl '\n'
#define mod3 998244353
#define mod7 1000000007
#define de(x) cerr << #x <<" "<<x <<" ";
#define deb(x) cerr << #x <<" "<<x <<endl;
using namespace std;

using pii = pair<int,int>;
using pll = pair<i64, i64>;
/* 赛时思路
 * 会成为很多个环
 * 
 * 如果总数为偶数的话,则最后 剩余两位 是未婚的.且奇数环最多只有两个
 *
 * 其次是环,如果环是奇数的,那么最后会剩余一个 无法结婚的
 * 奇数环最后会产生 1,2,3,4,5
 * 产生 1,2;3,4
 * 2,3;4,5;
 * 5,1;2,3;
 * 三种情况
 *
 * 1,2,3,4,5,6,7
 * 1,2;3,4;,5,6; -> 7未结婚
 * 2,3;4,5;6,7;  -> 1未结婚
 * 3,4;5,6;7,1;  -> 2 未结婚
 * 4,5;6,7;1,2;  -> 3未结婚
 * n种情况
 * 
 * 偶数环存在 1,2,3,4,5,6
 * 1,2;3,4;5,6;
 * 2,3;4,5;6,1;
 * 只存在俩种情况
 *
 * 奇数链 有两种情况
 * 偶数链 有一种情况
 * 
 * 被拆一个
 * 偶数 -> 一个奇数链 
 *
 * 奇数 -> 一个偶数链
 * 
 * 被拆两个
 * 偶数 -> 两个奇数链
 *
 * 偶数 -> 两个偶数链
 *
 * 奇数 -> 一个偶数链 + 一个奇数链
 *
 * 也就是奇环个数不得超过两个，否则解为0
 */

// 2025.07.17——21:02:58
/*
 * 因为n一定为偶数，所以奇数环的个数也一定为偶数，否则奇数个奇数相加不为偶数
 * 居民可以爱自己，如果奇数环且，奇数为1 的情况下，则该环必选
 * 当奇数环的个数为4时，则消去的点，必然无解
 *
 * 当奇数环的个数为2的时候，则选中的消去的点一定在奇数环中，方案数，为奇数环的长度
 * 偶数环的话，则 一个偶数环有两种不同的方案，所以解就是偶数环的方案数量进行相乘即可
 *
 * 当没有奇数环的时候，
 * 偶数环被选中两个，将会变成两个奇数链，不存在
 * 
 * 所以选中的话
 * 一种是相邻的两个人被选中，链的话就只有一种情况，
 *
 * 还有一种是选中的两个人之间的距离为偶数，
 * 所以一个环不同的数对就有，（设n为环的长度）距离为0，则有n（非二元环），
 * 【二元环的话就只有 距离为0 的存在，且只有一种被消去的情况】
 * 差值可以从 1，3，5，7，9，n/2+1 ；这样的距离
 * 在最后n-2的距离种，其所能够得到的
 * 返回上一个逻辑，距离为2，则存在
 * 差值为：1,3,5,7,9,11
 * 1 2 3 4 5 6 7 8 9 10 11 12
 * 1 : [1，2];[2，3];[3,4];[4,5];[5,6];[6,7];[7,8];[8,9];[9,10];[10,11][11,12];[12,1],12个
 * 3 : [1,4];[2,5];[3,6];[4,7];[5,8];[6,9];[7,10];[8,11];[9,12];[10,1];[11,2];[12,3];12种
 * 5 : [1,6];[2,7];[3,8];[4,9];[5,10][6,11][7,12][8,1][9,2][10,3][11,4][12,5]十二种
 * 7 : [1,8][2,9][3,10][4,11][5,12][6,1][7,2][8,3][9,4][][][][]和产嘀咕为5 的重复了
 *距离就是小于等于 n/2
 * 如果是6呢 1 ，3
 * 1 2 3 4 5 6
 * [1,2][2,3][3,4][4,5][5,6][6,1] n种
 * [1,4][2,5][3,6][4,1][5,2][6,3] 就需要除以2了
 * [1,6][2,1][3,2][][][][][] 和差值为1 的完全重复了
 * 就是n/2种类而非n种；
 * 可以直接求长度距离内有多少个奇数即可，然后将总数除以2 即可
 * (n/2 * n)/2
 *
 * 1 2 3 4 5 6 7 8 n = 8的情况下呢?
 * 1《==》[1,2][2,3][3,4][4,5][5,6][6,7][7,8][8,1]
 * 3《==》[1,4][2,5][3,6][4,7][5,8][6,1][7,2][8,3]
 * 5《==》[1,6][2,7][3,8][4,1][5,2][6,3][7,4][8,5] 重复了奇数个数 * n
 * 7《==》[1,8][][][][][][][][][] 重复了
 * 
 */
i64 pw(i64 a, i64 b) {
    i64 res = 1LL;
    while (b) {
        if (b & 1)res = res * a % mod3;
        a = a * a % mod3;
        b >>= 1LL;
    }
    return res % mod3;
}
i64 inv(i64 a) {
    return pw(a, mod3 - 2);
}

void solve() {
    i64 n;
    cin >> n;
    vector<i64>a(n+1),f(n+1,0);
    for (int i = 0;i <= n;i ++) {f[i] = -1;}
    for (int i = 1;i <= n;i ++) { cin >> a[i];}

    auto fd = [&](auto self, i64 fa)->i64 {
        if (f[fa] < 0) {
            return fa;
        }
        return f[fa] = self(self, f[fa]);
        };
    auto uni = [&](i64 x, i64 y)->void {
        i64 nx = fd(fd, x), ny = fd(fd, y);
        if (nx > ny)swap(nx, ny);
        if (nx == ny)return;
        f[nx] += f[ny];
        f[ny] = nx;
        return;
        };
        
    for (int i = 1;i <= n;i++) { uni(a[i], i); }
    i64 cir_two = 0;
    vector<i64>cir_odd, cir_even,vis(n+1,0);
    for (i64 i = 1;i <= n;i++) {
        i64 nx = fd(fd, i);
        if (vis[nx] == 1) { continue; }
        i64 v = -f[nx];
        vis[nx] = 1;
        if (v % 2) {
            cir_odd.push_back(v);
        } else {
            cir_even.push_back(v);
            if (v == 2LL) {
                cir_two++;
            }
        }
    }
    i64 even_sz = cir_even.size(),odd_size = cir_odd.size();
    if (odd_size >= 4) {
        cout << 0LL << endl;
        return;
    }
    if (odd_size == 2) {
        cout << pw(2, (even_sz-cir_two)) * cir_odd[0] % mod3 * cir_odd[1] % mod3 << endl;
        return ;
    }
    i64 sum = pw(2, even_sz-cir_two) % mod3;
    i64 ans = 0LL;
    for (int i = 0;i < even_sz;i++) {
        i64 v = cir_even[i];
        if (v == 2LL) {
            (ans += sum) %= mod3;
        }
        // i64 k = (v / 2LL) * v / 2LL;
        (ans += (sum * inv(2LL) % mod3 * (v / 2LL * v / 2LL) % mod3) % mod3) %= mod3;
    }
    cout << ans << endl;
}
// 2025.07.17——22:01:39 wa 43.9
int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int T;
    cin >> T;

    while(T--){
        solve();
    }
    return 0;
}