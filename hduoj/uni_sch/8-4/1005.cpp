// 看什么看,以为我厉害吗？
// 我只是戾气很重,不厉害只需要114514分钟就能变厉害了
// 而你我的朋友只需要2.5年就可以了
#include<bits/stdc++.h>
#include<climits>


#define all(x) x.begin(),x.end()
#define pb(x) push_back(x)
#define i64 long long
#define fi first
#define se second

#define endl '\n'
#define mod3 998244353
#define mod7 1000000007
#define de(x) cerr << #x <<" "<<x <<" ";
#define deb(x) cerr << #x <<" "<<x <<endl;
using namespace std;

using pii = pair<int,int>;
using pll = pair<i64, i64>;

// 2025.08.04——15:17:57

/*
 * 题目意思 给出一条节点数为 2 n 的树
 * 然后有n 把钥匙  和 n 把锁 ， 钥匙和锁是对应的 ，所有的钥匙和锁分布在各个 节点上
 * 现在需要 判断是否 能够拿到所有的钥匙
 * 输出 一个按照 钥匙编号 的节点开始 是否能够得到所有的 钥匙
 * 输出一个 01 字符串
 *
 * 第一次的思路，
 * 先dfs  一遍按照锁的位置进行 把钥匙并查集
 *
 * 知道自己走到哪里可以有 多少把钥匙
 * 然后根据 节点的度 从小到大遍历 也就是 从叶子节点开始遍历
 * 只要有一个点可以打开  那么和这个点 相连的所有的点都是 可以收集到所有钥匙的点
 *
 * 没有 其他的可能存在的点了吗？
 * 不存在 因为 如果 被分开 则一定有锁 但是如果被通过则说明 先前走的步中 有通往其他连通块的钥匙
 * 但是 其他连通块没有 ，所以其他的 连通块无法到达该连通块， 则不可能收集所有的钥匙
 * 得证
 * 并且 如果 从一个地方 已经过了一个 锁到达了下一个连通块，如果无法再到任何一个下一个连通块的情况下
 * 则最后会产生 所有块都无解的情况
 *
 * 实现：
 * 初始化 ans 字符串
 * 进行 钥匙连通块 的 判断
 * 对于连通块进行遍历即可 ，我们需要知道连通块之间的锁有哪些
 * 所以可以重新建立一个图
 * 其含义代表的 是 连通块之间相互到达的锁
 * 维护一个 vector 锁的个数 以及 锁的id
 *
 * 所以可以维护一个边图， 其包含来点 和 到点
 * 以及一个 vector<> 锁
 *
 * 其中来点 和 到点 代表的是连通块
 *
 * 现在需要优化时间复杂度O(n (n + m)) 就是
 * 如果我们 从一个连通块开始 到达了另外一个联通块，则这个联通块中的点不需要被遍历了
 * 因为绝对是无解
 *
 * 那么我们只需要去遍历其他的所有还没有被遍历的连通块
 * 这时候 直到去找到一个可以全部遍历的联通块        
 *
 *
*/

void solve(){





}

int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int T;
    cin >> T;
    while(T--){
        solve();
    }
    return 0;
}